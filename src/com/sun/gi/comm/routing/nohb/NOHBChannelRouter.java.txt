package com.sun.gi.comm.routing.nohb;

import java.io.*;
import java.net.*;
import java.util.*;

import com.sun.gi.comm.routing.*;
import com.sun.gi.utils.*;
import com.sun.multicast.reliable.transport.lrmp.*;

class ChannelRecord {
  boolean announced = false;
 // NOHBChannelID localID = new NOHBChannelID();
  List listeners = new ArrayList();
}

/**
 *
 * <p>Title: NOHBRouter</p>
 * <p>Description: This is an implementastion of the Router interface
 * that requires no heartbeats to function.  The current version has a
 * flaw for long-term use in that channels and aliases for them are
 * persisted for the life of the router.  A version should
 * age and remove unused channels and their alises.</p>
 * <p>Copyright: Copyright (c) 2004</p>
 * <p>Company: </p>
 * @author Jeffrey P. Kesselman
 * @version 1.0
 */


/** svaed for posterity (**/
public class NOHBChannelRouter {
  private static InetAddress address = null;
  private static int dataPort = 6824;
  private static String addr = "224.100.100.224";
  Map channelRecordsByID = new HashMap();
  Map channelRecordsByName = new HashMap();
  LRMPSocketManager cmgr;
  UUID myID;
  private static final byte OP_CTRL_NEW_ALIAS = 1;
  private static final byte OP_CHANNEL_PKT = 2;
  private static final byte OP_CTRL_ALIAS_RESPONSE = 3;
  private static final boolean LOOPBACK = true;
  private List userListeners = new ArrayList();

  public NOHBChannelRouter() {
    myID = new StatisticalUUID();
    // property based overrides for constants
    String prop = System.getProperty("com.sun.gi.comm.routing.gtg.mcastaddress");
    if (prop != null) {
      addr = prop;
    }
    prop = System.getProperty("com.sun.gi.comm.routing.gtg.mcastport");
    if (prop != null) {
      dataPort = Integer.parseInt(prop);
    }
    try {
      address = InetAddress.getByName(addr);
      LRMPTransportProfile tp = new LRMPTransportProfile(address, dataPort);
      tp.setMaxDataRate(100000);
      tp.setOrdered(true);
      cmgr = new LRMPSocketManager(tp);
      cmgr.addListener(this);
    }
    catch (Exception e) {
      e.printStackTrace();
    }
  }

  /**
   * addChannelListener
   *
   * @param id ChannelID
   * @param listener ChannelListener
   */
  public void addChannelListener(ChannelID id, ChannelListener listener) {
    ChannelRecord rec = (ChannelRecord)channelRecordsByID.get(id);
    if (rec == null) {
      System.err.println(
      "Error: Attempt to attach listener to unknown channel "+id);
      return;
    }
    rec.listeners.add(listener);
  }

  /**
   * createUser
   *
   * @return UserID
   */
  public UserID createUser() {
    UserID nid = new NOHBUserID();
    for(Iterator i= userListeners.iterator();i.hasNext();){
      ( (UserListener) i.next()).userAdded(nid);
    }
    return nid;
  }

  /**
  * disposeUser
  *
  * @param uid UserID
  */
 public void disposeUser(UserID uid) {
   for(Iterator i= userListeners.iterator();i.hasNext();){
     ((UserListener)i.next()).userRemoved(uid);
   }
 }


  /**
   * openChannel
   *
   * @param appName String
   * @param channelName String
   * @return ChannelID
   */
  public ChannelID openChannel(String appName, String channelName) {
    String canonicalName = appName+"_"+channelName;
    ChannelRecord rec = (ChannelRecord)channelRecordsByName.get(canonicalName);
    if (rec == null) { // new channel
      rec = new ChannelRecord();
      channelRecordsByName.put(canonicalName, rec);
      channelRecordsByID.put(rec.localID,rec);
    }
    if (!rec.announced){
       announceNewChannelAlias(canonicalName,rec.localID);
       rec.announced = true;
    }
    return rec.localID;
  }

  /**
   * addChannelAlias
   *
   * @param canonicalName String
   * @param id NOHBChannelID
   */
  private void addChannelAlias(String canonicalName, NOHBChannelID id) {
    ChannelRecord rec = (ChannelRecord)channelRecordsByName.get(canonicalName);
    if (rec == null) { // new channel
      rec = new ChannelRecord();
      channelRecordsByName.put(canonicalName,rec);
    }
    channelRecordsByID.put(id,rec);
  }

  /**
   * announceNewChannelAlias
   *
   * @param string String
   * @param id NOHBChannelID
   */
  private void announceNewChannelAlias(String name, NOHBChannelID id) {
    try {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(baos);
      oos.writeObject(myID);
      oos.writeByte(OP_CTRL_NEW_ALIAS);
      oos.writeObject(name);
      oos.writeObject(id);
      oos.flush();
      byte[] buff = baos.toByteArray();
      oos.close();
      baos.close();
      cmgr.send(new DatagramPacket(buff,buff.length));
    } catch (Exception e){
      e.printStackTrace(System.err);
    }
  }

  /**
   * sendChannelData
   *
   * @param from UserID
   * @param to ChannelID
   * @param data byte[]
   */
  public void sendChannelData(UserID from, ChannelID to, byte[] data) {
    try {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(baos);
      oos.writeObject(myID);
      oos.writeByte(OP_CHANNEL_PKT);
      oos.writeObject(from);
      oos.writeObject(to);
      oos.writeObject(data);
      oos.flush();
      byte[] buff = baos.toByteArray();
      oos.close();
      baos.close();
      cmgr.send(new DatagramPacket(buff,buff.length));
    } catch (Exception e){
      e.printStackTrace(System.err);
    }
     //a  bit of a ahck for multipel clients, prob a better soln
     // is possible
    if (LOOPBACK) {
      doChannelPkt(from,to,data);
    }
  }

  // LRMPSocketListener methods
  /**
   * packetArrived
   *
   * @param lRMPSocketManager LRMPSocketManager
   * @param inpkt DatagramPacket
   */
  public void packetArrived(LRMPSocketManager lRMPSocketManager,
                            DatagramPacket inpkt) {
    try {
      ByteArrayInputStream bais = new ByteArrayInputStream(inpkt.getData());
      ObjectInputStream ois = new ObjectInputStream(bais);
      UUID fromMgr = (UUID) ois.readObject();
      byte op = ois.readByte();
      switch(op) {
        case OP_CTRL_NEW_ALIAS:
          String canonicalName = (String)ois.readObject();
          ChannelID alias = (ChannelID)ois.readObject();
          newAliasRecvd(canonicalName,alias);
          break;
        case OP_CTRL_ALIAS_RESPONSE:
          canonicalName = (String)ois.readObject();
          alias = (ChannelID)ois.readObject();
          aliasResponseRecvd(canonicalName,alias);
          break;
        case OP_CHANNEL_PKT:
          UserID from = (UserID)ois.readObject();
          ChannelID to = (ChannelID)ois.readObject();
          byte[] data = (byte[])ois.readObject();
          doChannelPkt(from,to,data);
          break;
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  /**
   * doChannelPkt
   *
   * @param from UserID
   * @param to ChannelID
   * @param data byte[]
   */
  private void doChannelPkt(UserID from, ChannelID to, byte[] data) {
    ChannelRecord rec = (ChannelRecord)channelRecordsByID.get(to);
    if (rec != null) {
      synchronized(rec){
        for (Iterator i = rec.listeners.iterator(); i.hasNext(); ) {
          ( (ChannelListener) i.next()).channelDataArrived(to, from, data);
        }
      }
    }
  }

  /**
   * aliasResponseRecvd
   *
   * @param canonicalName String
   * @param alias ChannelID
   */
  private void aliasResponseRecvd(String canonicalName, ChannelID alias) {
    ChannelRecord rec  =
        (ChannelRecord)channelRecordsByName.get(canonicalName);
    channelRecordsByID.put(alias,rec);
  }

  /**
   * newAliasRecvd
   *
   * @param canonicalName String
   * @param alias UUID
   */
  private void newAliasRecvd(String canonicalName, ChannelID alias) {
    ChannelRecord rec  =
        (ChannelRecord)channelRecordsByName.get(canonicalName);
    if (rec == null) { // new
      rec = new ChannelRecord();
      channelRecordsByName.put(canonicalName, rec);
      channelRecordsByID.put(rec.localID,rec);
    }
    channelRecordsByID.put(alias,rec);
    sendNewAliasResponse(canonicalName,rec.localID);
  }

  /**
   * sendNewAliasResponse
   *
   * @param canonicalName String
   * @param channelID ChannelID
   */
  private void sendNewAliasResponse(String canonicalName, ChannelID channelID) {
    try {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     ObjectOutputStream oos = new ObjectOutputStream(baos);
     oos.writeObject(myID);
     oos.writeByte(OP_CTRL_ALIAS_RESPONSE);
     oos.writeObject(canonicalName);
     oos.writeObject(channelID);
     oos.flush();
     byte[] buff = baos.toByteArray();
     oos.close();
     baos.close();
     cmgr.send(new DatagramPacket(buff,buff.length));
   } catch (Exception e){
     e.printStackTrace(System.err);
   }

  }

  /**
   * socketClosed
   *
   * @param lRMPSocketManager LRMPSocketManager
   */
  public void socketClosed(LRMPSocketManager lRMPSocketManager) {
  }

  /**
   * addHostListener
   *
   * @param l HostListener
   */
  public void addUserListener(UserListener l) {
    userListeners.add(l);
  }

  /**
   * closeChannel
   *
   * @param id ChannelID
   */
  public void closeChannel(ChannelID id) {
  }

}
