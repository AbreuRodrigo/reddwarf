/*
 * Copyright 2007 Sun Microsystems, Inc. All rights reserved
 */

package com.sun.sgs.germwar.client.gui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.ItemSelectable;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.net.URL;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;

import com.sun.sgs.germwar.client.GameLogic;
import com.sun.sgs.germwar.shared.Coordinate;
import com.sun.sgs.germwar.shared.Location;
import com.sun.sgs.germwar.shared.Vector;

/**
 * A GermWar client GUI component that shows a large, zoomed-in portion of the
 * game world, along with various object that reside in the viewed area.
 */
public class MainMapPanel extends JPanel
    implements ItemSelectable, SelectableMap
{
    /** All of the actions that can be generated by buttons in this panel. */
    public static final String MAP_UP = "map_up";
    public static final String MAP_DOWN = "map_down";
    public static final String MAP_LEFT = "map_left";
    public static final String MAP_RIGHT = "map_right";

    /** Icons to show on the squares of the map. */
    private static final Icon MY_BACTERIA_ICON =
        new ImageIcon("benchmark/GermWarData/images/bacteria1.jpg");

    private static final Icon OTHER_BACTERIA_ICON =
        new ImageIcon("benchmark/GermWarData/images/bacteria2.gif");

    /** Size of the viewable map, in squares per side. */
    public static final int MAP_SIZE = 5;

    /** Used to print floating point numbers in the gui. */
    private final static NumberFormat decFormatter = new DecimalFormat(".#");

    /** Buttons to scroll the map in different directions. */
    private final JButton mapUpButton, mapDownButton, mapLeftButton,
        mapRightButton;
    
    /** Panel to hold the map itself. */
    private final JPanel mapPanel = new JPanel();

    /** 2-D array of squares that make up the map. */
    private final MapSquare[][] squares = new MapSquare[MAP_SIZE][MAP_SIZE];

    /**
     * The world coordinates of the upper-left square of the map; null if the
     * map has not been centered on anything yet.  Note that these can be set
     * even if the upper-left square has no Location assigned yet.
     */
    private Coordinate mapCornerCoord = null;

    /** The coordinate of the location currently selected by the user, if any. */
    private Coordinate activeCoord = null;

    /** Location of the square most recently clicked. */
    private Location clickedLocation = null;

    /** Used to look up various info needed to render the map. */
    private GameLogic gameLogic;

    /** Listeners registered for map selection events. */
    private List<ItemListener> itemListeners = new LinkedList<ItemListener>();

    /** The logger for this class. */
    private static final Logger logger =
        Logger.getLogger(MainMapPanel.class.getName());

    // Constructor

    /**
     * Creates a new {@code MainMapPanel}.
     */
    public MainMapPanel(GameLogic gameLogic, ClockTimer turnTimer) {
        super();
        this.gameLogic = gameLogic;

        ActionListener mapButtonListener = new MapButtonListener();

        mapUpButton = ArrowButton.newInstance(SwingConstants.NORTH);
        mapUpButton.setActionCommand("up");
        mapUpButton.addActionListener(mapButtonListener);

        mapDownButton = ArrowButton.newInstance(SwingConstants.SOUTH);
        mapDownButton.setActionCommand("down");
        mapDownButton.addActionListener(mapButtonListener);

        mapRightButton = ArrowButton.newInstance(SwingConstants.EAST);
        mapRightButton.setActionCommand("right");
        mapRightButton.addActionListener(mapButtonListener);

        mapLeftButton = ArrowButton.newInstance(SwingConstants.WEST);
        mapLeftButton.setActionCommand("left");
        mapLeftButton.addActionListener(mapButtonListener);

        /** Draw a line around the map. */
        mapPanel.setBorder(BorderFactory.createRaisedBevelBorder());

        /** Arrange squares in a square layout, with small gaps between them. */
        mapPanel.setLayout(new GridLayout(MAP_SIZE, MAP_SIZE, 1, 1));

        /** Used by all squares in the map. */
        MouseListener mouseListener = new MapMouseListener();

        /**
         * GridLayout fills across first, then down, so the outer loop has to
         * iterate rows and the inner loop columns in order for this to work
         * correctly.
         */
        for (int row=0; row < MAP_SIZE; row++) {
            for (int column=0; column < MAP_SIZE; column++) {
                MapSquare square = new MapSquare(column, row);
                square.addMouseListener(mouseListener);
                square.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
                mapPanel.add(square);
                squares[row][column] = square;
            }
        }

        this.addMouseListener(mouseListener);

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new GridLayout(1,3));
        topPanel.add(turnTimer, BorderLayout.WEST);
        topPanel.add(new ButtonWrapper(mapUpButton, 42, 45), BorderLayout.CENTER);
        topPanel.add(new JLabel());  /* just to take up space */

        setLayout(new BorderLayout());
        add(topPanel, BorderLayout.NORTH);
        add(new ButtonWrapper(mapDownButton, 42, 45), BorderLayout.SOUTH);
        add(new ButtonWrapper(mapLeftButton, 45, 42), BorderLayout.WEST);
        add(new ButtonWrapper(mapRightButton, 45, 42), BorderLayout.EAST);
        add(mapPanel, BorderLayout.CENTER);
    }

    /**
     * {@inheritDoc}
     * <p>
     * En/disable all widgets on this panel when its en/disabled.
     */
    @Override
    public void setEnabled(boolean enabled) {
        super.setEnabled(enabled);
        mapUpButton.setEnabled(enabled);
        mapDownButton.setEnabled(enabled);
        mapLeftButton.setEnabled(enabled);
        mapRightButton.setEnabled(enabled);

        if (!enabled) setSelected(null);

        mapCornerCoord = null;

        for (int row=0; row < MAP_SIZE; row++) {
            for (int column=0; column < MAP_SIZE; column++) {
                squares[row][column].setEnabled(enabled);
            }
        }
    }

    /**
     * Returns the {@link MapSquare} that currently represents the {@link
     * Location} at coordinate {@code coord}, or {@code null} if {@code coord}
     * indexes a Location that is outside the current view of the map.
     */
    private MapSquare getMapSquare(Coordinate coord) {
        Vector diff = mapCornerCoord.diff(coord);

        if ((diff.getX() >= 0) && (diff.getX() < MAP_SIZE) &&
            (diff.getY() >= 0) && (diff.getY() < MAP_SIZE))
        {
            return squares[diff.getY()][diff.getX()];
        } else {
            return null;
        }
    }

    /**
     * Checks each square of the map to see if it needs to be reloaded.
     */
    public synchronized void refresh() {
        for (int row=0; row < MAP_SIZE; row++) {
            for (int column=0; column < MAP_SIZE; column++) {
                if (mapCornerCoord == null) {
                    squares[row][column].setWorldLocation(null);
                } else {
                    Coordinate c = mapCornerCoord.offsetBy(column, row);
                    MapSquare mapSquare = getMapSquare(c);

                    if (activeCoord != null) {
                        mapSquare.setBorder(c.equals(activeCoord) ?
                            BorderFactory.createLineBorder(Color.RED, 2) :
                            BorderFactory.createEmptyBorder(2, 2, 2, 2));
                    }

                    mapSquare.setWorldLocation(gameLogic.getLocation(c));
                }
            }
        }
    }

    // Implement SelectableMap

    /**
     * {@inheritDoc}
     */
    public synchronized Coordinate getSelected() {
        return activeCoord;
    }

    /**
     * {@inheritDoc}
     */
    public synchronized void setFocus(Coordinate coord) {
        int cornerX = (int)coord.getX() - MAP_SIZE/2;
        if (cornerX < 0) cornerX = 0;
        int cornerY = (int)coord.getY() - MAP_SIZE/2;
        if (cornerY < 0) cornerY = 0;

        mapCornerCoord = new Coordinate(cornerX, cornerY);
        refresh();
    }

    /**
     * {@inheritDoc}
     */
    public synchronized void setSelected(Coordinate coord) {
        if (activeCoord != null) {
            MapSquare mapSquare = getMapSquare(activeCoord);
            if (mapSquare != null)
                mapSquare.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
        }

        activeCoord = coord;
        refresh();
    }

    /**
     * {@inheritDoc}
     */
    public synchronized void update(Location loc) {
        if (mapCornerCoord == null) {
            /** Center map on this new Location. */
            setFocus(loc.getCoordinate());
            logger.log(Level.INFO, "Initialized mapCornerCoord to " +
                mapCornerCoord);
        }

        MapSquare mapSquare = getMapSquare(loc.getCoordinate());
        if (mapSquare != null) mapSquare.setWorldLocation(loc);
        // else, off the map, so we don't care
    }

    // Implement ItemSelectable

    /*
     * {@inheritDoc}
     */
    public void addItemListener(ItemListener l) {
        itemListeners.add(l);
    }

    /*
     * {@inheritDoc}
     */
    public Object[] getSelectedObjects() {
        return new Object[] { clickedLocation };
    }

    /*
     * {@inheritDoc}
     */
    public void removeItemListener(ItemListener l) {
        itemListeners.remove(l);
    }

    /** 
     * Inner class: MapSquare. Rows and columns are indexed from 0, starting
     * with the top-left corner of the map.
     */
    private final class MapSquare extends JPanel {
        /** Position of this square in the overall map. */
        private final int column, row;

        /** The world location that this square currently represents. */
        private Location worldLoc;

        /** The visual display of this square. */
        private JLabel label;

        /** Creates a new {@code MapSquare}. */
        public MapSquare(int column, int row) {
            super();
            this.column = column;
            this.row = row;
            this.worldLoc = null;
            this.label = new JLabel();

            label.setMaximumSize(new Dimension(72,72));
            label.setMinimumSize(new Dimension(72,72));
            label.setHorizontalAlignment(SwingConstants.CENTER);

            setLayout(new java.awt.GridLayout(1, 1));
            add(label);

            setGraphics();
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean isValidateRoot() { return true; }

        /** Returns this square's column position in the map. */
        public int getColumn() { return column; }

        /** Returns the world location that this square currently represents. */
        public Location getWorldLocation() { return worldLoc; }

        /** Returns this square's row position in the map. */
        public int getRow() { return row; }

        /**
         * {@inheritDoc}
         * <p>
         * Change appearance when disabled.
         */
        @Override
        public void setEnabled(boolean enabled) {
            super.setEnabled(enabled);
            setGraphics();
        }

        /**
         * Sets this square to represent {@code locaction}, which repaints this
         * square's content.
         */
        public void setWorldLocation(Location loc) {
            if ((loc == null) && (worldLoc == null)) return;  // efficiency
            worldLoc = loc;
            setGraphics();
        }

        /**
         * Paints this panel.
         */
        private void setGraphics() {
            label.setIcon(null);
            label.setText("");

            if (isEnabled() == false) return;

            if (worldLoc == null) {
                label.setText("?");
            } else if (worldLoc.isOccupied()) {
                if (worldLoc.getOccupant().getPlayerId() ==
                    gameLogic.getPlayerId())
                {
                    label.setIcon(MY_BACTERIA_ICON);
                } else {
                    label.setIcon(OTHER_BACTERIA_ICON);
                }
            } else {
                label.setText(decFormatter.format(worldLoc.getFood()));
            }

            revalidate();
        }
    }

    /** Inner class: MapButtonListener */
    private final class MapButtonListener implements ActionListener {
        /** Creates a new {@code MapButtonListener}. */
        public MapButtonListener() {
            // empty
        }

        // implement ActionListener

        /**
         * {@inheritDoc}
         */
        public void actionPerformed(ActionEvent e) {
            if (mapCornerCoord == null) return;

            String cmd = e.getActionCommand();
            int offsetX = 0, offsetY = 0;

            if (cmd.equals("up")) {
                offsetY = -1;
            } else if (cmd.equals("down")) {
                offsetY = 1;
            } else if (cmd.equals("left")) {
                offsetX = -1;
            } else if (cmd.equals("right")) {
                offsetX = 1;
            } else {
                logger.log(Level.SEVERE, "Unknown action command in" +
                    " MapButtonListener: " + cmd);
                return;
            }

            mapCornerCoord = mapCornerCoord.offsetBy(offsetX, offsetY);
            refresh();
        }
    }

    /** Inner class: MapMouseListener */
    private final class MapMouseListener extends MouseAdapter {
        /** Creates a new {@code MapMouseListener}. */
        public MapMouseListener() {
            // empty
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void mouseClicked(MouseEvent e) {
            Component target = e.getComponent();
            ItemEvent evt;

            if (target instanceof MapSquare) {
                MapSquare square = (MapSquare)target;
                if (mapCornerCoord == null) return;

                clickedLocation = square.getWorldLocation();

                evt = new ItemEvent(MainMapPanel.this,
                    ItemEvent.ITEM_STATE_CHANGED,
                    clickedLocation,
                    ItemEvent.SELECTED);
            } else {
                clickedLocation = null;
                evt = new ItemEvent(MainMapPanel.this,
                    ItemEvent.ITEM_STATE_CHANGED,
                    null,
                    ItemEvent.DESELECTED);
            }
            
            for (ItemListener l : itemListeners)
                l.itemStateChanged(evt);
        }
    }
}
